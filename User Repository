package yg.bootcamp.demo.service;

import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

import java.time.LocalDate;
import java.util.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import yg.bootcamp.demo.dto.GraphDTO;
import yg.bootcamp.demo.dto.StatsDTO;
import yg.bootcamp.demo.entity.Expense;
import yg.bootcamp.demo.entity.Income;
import yg.bootcamp.demo.repository.ExpenseRepository;
import yg.bootcamp.demo.repository.IncomeRepository;

public class StatsServiceTest {

    @InjectMocks
    private StatsService statsService;

    @Mock
    private IncomeRepository incomeRepository;

    @Mock
    private ExpenseRepository expenseRepository;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.initMocks(this);
    }

    @Test
    public void testGetChartData() {
        int userId = 1;
        LocalDate startDate = LocalDate.now().minusDays(365);
        LocalDate endDate = LocalDate.now();

        List<Expense> mockExpenses = Arrays.asList(new Expense());
        List<Income> mockIncomes = Arrays.asList(new Income());

        when(expenseRepository.findByCreatedDateBetweenAndUserId(startDate, endDate, userId)).thenReturn(mockExpenses);
        when(incomeRepository.findByCreatedDateBetweenAndUserId(startDate, endDate, userId)).thenReturn(mockIncomes);

        GraphDTO result = statsService.getChartData(userId);

        assertNotNull(result);
        assertEquals(mockExpenses, result.getExpenseList());
        assertEquals(mockIncomes, result.getIncomeList());

        verify(expenseRepository, times(1)).findByCreatedDateBetweenAndUserId(startDate, endDate, userId);
        verify(incomeRepository, times(1)).findByCreatedDateBetweenAndUserId(startDate, endDate, userId);
    }

    @Test
    public void testGetStats() {
        int userId = 1;

        Double totalIncome = 1000.0;
        Double totalExpense = 800.0;
        Income latestIncome = new Income();
        latestIncome.setAmount(500.0);
        Expense latestExpense = new Expense();
        latestExpense.setAmount(200.0);

        List<Income> incomeList = Arrays.asList(latestIncome);
        List<Expense> expenseList = Arrays.asList(latestExpense);

        when(incomeRepository.sumAllAmountsByUserId(userId)).thenReturn(totalIncome);
        when(expenseRepository.sumAllAmountsByUserId(userId)).thenReturn(totalExpense);
        when(incomeRepository.findFirstByUserIdOrderByCreatedDateDesc(userId)).thenReturn(Optional.of(latestIncome));
        when(expenseRepository.findFirstByUserIdOrderByCreatedDateDesc(userId)).thenReturn(Optional.of(latestExpense));
        when(incomeRepository.findByUserId(userId)).thenReturn(incomeList);
        when(expenseRepository.findByUserId(userId)).thenReturn(expenseList);

        StatsDTO result = statsService.getStats(userId);

        assertNotNull(result);
        assertEquals(totalIncome, result.getIncome());
        assertEquals(totalExpense, result.getExpense());
        assertEquals(200.0, result.getMinExpense());
        assertEquals(500.0, result.getMaxIncome());
        assertEquals(500.0, result.getLatestIncome().getAmount());
        assertEquals(200.0, result.getLatestExpense().getAmount());

        verify(incomeRepository, times(1)).sumAllAmountsByUserId(userId);
        verify(expenseRepository, times(1)).sumAllAmountsByUserId(userId);
        verify(incomeRepository, times(1)).findFirstByUserIdOrderByCreatedDateDesc(userId);
        verify(expenseRepository, times(1)).findFirstByUserIdOrderByCreatedDateDesc(userId);
        verify(incomeRepository, times(1)).findByUserId(userId);
        verify(expenseRepository, times(1)).findByUserId(userId);
    }
}
